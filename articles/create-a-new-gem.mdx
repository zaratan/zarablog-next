---
title: "Anatomie d'une gem Ruby"
date: 2021-01-04T14:33:13+09:00
categories:
  - ruby
  - code
description: "Cet article à pour but de couvrir tout le processus d'édition d'une gem. Il sera découpé en deux grandes parties."
---

Cet article à pour but de couvrir tout le processus d'édition d'une gem. Il sera découpé en deux grandes parties. Tout d'abord ce qu'il faut savoir à minima pour créer sa propre gem (honnêtement, pas grand chose) pour que vous puissiez créer la votre sans soucis. Je vais ensuite donner mes recommandations (subjectives) quand aux outils et bonnes pratiques concernant l'écriture et le maintient de cette gem.

## Savoir minimal

Tout d'abord on va voir ce qu'il faut savoir à minima. Ce "chapitre" va essayer de couvrir tout ce qui rend différent une gem d'un script ruby qu'on écrit dans un coin.

### Création d'une nouvelle gem

Tout d'abord, comment on "crée" une gem ? La bonne question est, qu'est-ce qu'est le "minimal" pour avoir une gem ?

- Un dossier duquel on va pouvoir require des fichiers ruby
- Un fichier en `.gemspec`
  Donc par rapport à un script normal, tout ce qui change c'est le fichier `.gemspec`. On va détailler ses différentes sections [plus bas](#le-fichier-.gemspec) dans cet article.

Cependant on peut utiliser un utilitaire qui va nous créer un squelette un peu moins "vide". [bundler](https://bundler.io/v2.2/man/bundle-gem.1.html) que vous avez tous déjà utilisé permet de créer un bon premier squelette.

La commande que j'utilise la plupart du temps est:
bundle gem nom_de_ma_gem --coc --mit --test=rspec

- `--coc` va créer un fichier de code of conduct.
- `--mit` va ajouter le fichier de license de [MIT].
- `--test=rspec` va instancier les quelques fichiers par défaut de `rspec`.

Dans la section suivante on va détailler les différentes parties de cette arborescence.

### Arborescence par défaut

Voilà l'arborescence crée par bundler:

<Image
  src="/articles/create-a-new-gem/tree-new-gem.png"
  alt="Arborescence des différents fichiers d'une nouvelle gem."
  height="656"
  width="644"
/>

- `CODE_OF_CONDUCT.md` contient un coc minimaliste.
- `LICENSE.txt` va contenir la license MIT pour votre gem.
- `Rakefile` va contenir les taches de déploiement d'une gem.
- `lib/ma_belle_gem.rb` va contenir le fichier vide qui contiendra plus tard le code d'initialisation de votre gem. Ce fichier sera automatiquement require quand quelqu'un ajoutera votre gem à son Gemfile.
- `lib/ma_belle_gem/version.rb` va définir la constante MaBelleGem::VERSION qui contiendra le numéro de version courant de votre gem.
- le dossier `spec` va contenir les quelques fichiers classique de tests en rspec.
- le dossier `bin` va contenir les scripts utiles au development.
  - `setup` va servir à setup l'environment de development (en général juste `bundle install`).
  - `console` va lancer une console ruby avec votre gem pre-chargée.

##### le fichier .gemspec

Le fichier `.gemspec` est particulier et possède de nombreuses sections plus-ou-moins optionnelles. On va décortiquer celui qui est généré par `bundler`, mais vous pouvez aller voir [ici pour la documentation complète](https://guides.rubygems.org/specification-reference/).

```ruby
# Charge votre fichier qui défini la version de votre gem dans la constante MaBelleGem::VERSION.
require_relative 'lib/ma_belle_gem/version'

Gem::Specification.new do |spec|
  # Le nom de votre gem (Obligatoire). Ce nom sera utilisé pour:
  # * Le nom de votre gem dans rubygems;
  # * Le nom du fihcier qui sera chargé par défaut (lib/ma_belle_gem.rb).
  spec.name          = "ma_belle_gem"
  # Votre numéro de version. Sa valeur sera utilisée dans rubygems. (Obligatoire)
  spec.version       = MaBelleGem::VERSION
  # La liste des auteurs de la gem (Obligatoire d'avoir au moins un auteur)
  spec.authors       = ["Denis <Zaratan> Pasin"]
  # La liste des emails des auteurs de la gem.
  # Attention cette information est publique sur rubygems. (Obligatoire d'avoir au moins un email)
  spec.email         = ["zaratan@hey.com"]

  # summary doit contenir un rapide résumé de ce que fait votre gem.
  # Je ne suis pas sur de où cette information est utilisée. (Obligatoire)
  spec.summary       = %q{TODO: Write a short summary, because RubyGems requires one.}
  # description doit contenir une "longue" description de ce à quoi sert votre gem.
  # Cette information sera affichée tel quelle sur rubygems. (Optionel (mais pas vraiment en pratique))
  spec.description   = %q{TODO: Write a longer description or delete this line.}
  # En général la homepage sera votre repo github a moins que vous ne créiez un site dédié à votre gem.
  spec.homepage      = "TODO: Put your gem's website or public repo URL here."
  # Le shortname de la license
  spec.license       = "MIT"
  # La version de Ruby minimale.
  # Je vous conseille de set cette version à la dernière version de Ruby qui n'est pas en EOL (End Of Life).
  # Voir: https://www.ruby-lang.org/en/downloads/
  spec.required_ruby_version = Gem::Requirement.new(">= 2.3.0")

  # Section optionnelle. Si ce n'est pas scécifié c'est rubygems.org (en général je supprime cette section).
  spec.metadata["allowed_push_host"] = "TODO: Set to 'http://mygemserver.com'"

  spec.metadata["homepage_uri"] = spec.homepage
  # L'url de l'emplacement de votre code
  spec.metadata["source_code_uri"] = "TODO: Put your gem's public repo URL here."
  # L'url qui permet d'acceder à votre changelog. Cette section est optionnelle. Si vous n'avez pas de changelog supprimez la.
  spec.metadata["changelog_uri"] = "TODO: Put your gem's CHANGELOG.md URL here."

  # La section files va permettre de
  # supprimer des fichier qui ne doivent pas être inclus dans la release de votre gem (genre les tests).
  # En général cette section reste inchangée.
  # Specify which files should be added to the gem when it is released.
  # The `git ls-files -z` loads the files in the RubyGem that have been added into git.
  spec.files         = Dir.chdir(File.expand_path('..', __FILE__)) do
    `git ls-files -z`.split("\x0").reject { |f| f.match(%r{^(test|spec|features)/}) }
  end
  # Le dossier dans lequel les executable seront mis
  # (par exemple `bundle` pour la gem de bundler et `rails` pour la gem de rails)
  # Ce dossier peut ne pas exister.
  spec.bindir        = "exe"
  spec.executables   = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }
  # Quels dossier seront "require" automatiquement au démarrage de votre gem.
  # Pareil en général, pas de changement ici.
  spec.require_paths = ["lib"]
end
```

Les deux types de commades qui seront très souvent présentes dans un gemspec sont:

- `spec.add_development_dependency`

Va ajouter une gem qui ne sera installée que dans le contexte du development de la gem (`rspec` par exemple). La syntaxe est la même que dans un Gemfile :

```ruby
spec.add_development_dependency "rubocop", "> 0.58"
```

- `spec.add_dependency`

Va ajouter une dépendence directe de votre gem. Celle-ci sera installée par tous les projets qui utilisent votre gem.

Pareil, même syntaxe que dans un Gemfile :

```ruby
spec.add_dependency "activesupport", "> 2.0"
```

### Le déploiement

Une fois que votre gemspec est défini on peut déployer sur [rubygems.org](https://rubygems.org) et rentre notre gem disponible au monde.

Il faut absolument avoir un compte de créé sur rubygems.org.

Ensuite, si vous avez utilisé `bundler` pour créer votre gem. Il suffit de faire: `rake release` dans un terminal et Rake s'occupera pour vous de la publication.
À savoir:

- Creer un package avec le code de votre gem.
- Creer un [tag git](https://git-scm.com/book/en/v2/Git-Basics-Tagging) avec votre numéro de version.
- Faire un `git push` avec vos commits et vos tags.
- Publier votre gem sur rubygems (Il est possible/probable que vous deviez entrer votre username/password ici).

Et voilà. Après quelques minutes, n'importe qui pourra utiliser votre gem.

## Des outils pratiques

Dans la partie précédente on a pu voir ce qu’il fallait pour avoir une gem minimale.
On va maintenant passer en revue quelques outils (gems) que j’inclus dans quasiment toutes les gems que j’utilise.
Nottez que quasiment toutes ces recommandations s’appliqueraient aussi à un projet Rails.
Ces outils ne sont effectivement pas du tout liés au processus de création d’une gem.

### Rubocop

Commençons par [Rubocop](https://rubocop.org)que vous devez tous plus ou moins connaitre.
Pour moi, c’est plus ou moins obligatoire de l’utiliser dans un projet
(Ou un “_équivalent_” genre [reek](https://github.com/troessner/reek)).

Utiliser rubocop permet plusieurs choses:

- C’est une façon de normaliser le look du code à travers un projet. Ça permet d’ouvrir n’importe quel fichier et d’avoir un “style” consistant.
- Ça règle toute discussion futile autour du style dans une PR. Si le linter ne force pas un style, alors cette façon de coder est valide.
- Ça permet de s’assurer que certaines règles de performance sont respectées, que certaines syntaxes dangereuses ne sont pas utilisées ou encore que certaine erreurs évitables le sont.

Pour ajouter Rubocop à notre gem on ajoute dans le `.gemspec` :

```ruby
spec.add_development_dependency "rubocop"
spec.add_development_dependency "rubocop-performance"
```

Voici un exemple de configuration que j’utilise dans presque toutes mes gems:

```yaml
# Utiliser une version (peu) édulcorée des règles de base de rubocop
inherit_from:
  - http://relaxed.ruby.style/rubocop.yml

# Ajoute des règles de performance aux règles de base de Rubocop
require:
  - rubocop-performance

AllCops:
  # Chaque version de rubocop ajoute de nouvelles règles.
  # Ceci les active par défaut.
  NewCops: enable
  DisplayStyleGuide: true
  DisplayCopNames: true
  Exclude:
    - "bin/*"
    - "vendor/**/*"

# Certains fichiers sont de gigantesques block.
# Ne pas les compter.
Metrics/BlockLength:
  Exclude:
    - "spec/**/*.rb"
    - "Guardfile"
    - "vendor/bundle"
    - "*.gemspec"

# Les règles qui vont suivre sont des règles de style
# permettant de split les lignes.
Layout/DotPosition:
  Enabled: true
  EnforcedStyle: trailing

Style/TrailingCommaInArrayLiteral:
  Enabled: true
  EnforcedStyleForMultiline: comma

Style/TrailingCommaInHashLiteral:
  Enabled: true
  EnforcedStyleForMultiline: comma

Layout/MultilineArrayLineBreaks:
  Enabled: true

Layout/MultilineHashKeyLineBreaks:
  Enabled: true

Layout/MultilineMethodArgumentLineBreaks:
  Enabled: true

Layout/FirstArrayElementLineBreak:
  Enabled: true

Layout/FirstHashElementLineBreak:
  Enabled: true

Layout/FirstMethodArgumentLineBreak:
  Enabled: true

Layout/MultilineAssignmentLayout:
  Enabled: true

# Ajoute une limite maximum à la longueur d'une ligne
Layout/LineLength:
  Enabled: true
  Max: 120
  # Cette option fait en sorte que Rubocop essaye d'ajouter
  # des retours à la ligne là où il faut.
  AutoCorrect: true
  Exclude:
    - Gemfile
    - Guardfile
```

##### Bonus: Autocorrect rapide

Il arrive souvent qu’on veuille lancer Rubocop sur l’ensemble du projet et corriger chaque fichier qui a un problème. Rubocop à deux options mutuellement exclusives:

- `-P` permet de vérifier les fichiers en parallèle et donc de profiter des nombreux cœurs de nos CPU modernes
- `-A`permet de corriger les fichiers automatiquement.

Comme on ne peut pas utiliser les deux options en même temps on va définir un alias qui utilise automatiquement le résultat de du mode rapide (`-P`) comme paramètre du mode (`-A`) et ne corriger (lentement) que les fichiers qui ont des problèmes.

```bash
alias fastcop="rubocop -P -f fi | xargs rubocop -A"
```

### Solargraph

[Solargraph](https://solargraph.org)est une gem qui permet d’ajouter un “Language Server” à votre projet Ruby. Qu’est ce qu’un language server me direz vous ? C’est un utilitaire qui va tourner en tache de fond et permettre a votre IDE de lui poser des questions telles que: “Quelle est la documentation de cette méthode ?” ou “Quelles sont les méthodes disponibles sur cet classe/objet ?” ou encore “Quels sont les arguments de cette méthode ?”. Ça permet ensuite à notre IDE de fournir une bien meilleure autocomplétion.

On l’ajoute à notre projet de la manière suivante:

```ruby
spec.add_development_dependency "solargraph"
```

Et on peut ensuite demander à solargraph de télécharger les documentations disponibles.

```bash
# Télécharge la documentation de tel ruby
solargraph download-core 2.7.2

# Compile la documentation de toutes les gems
# utilisées dans le projet
solargraph bundle
```

Chaque IDE a sa propre façon de se connecter à solargraph. Le comment lier son IDE a solargraph [sera laissé en exercice au lecteur](https://solargraph.org).

##### Bonus VS Code configuration

Je vais quand même fournir quelques options de configuration que j’utilise pour solargraph à l’intérieur de VS Code.

```json
"solargraph.diagnostics": true,
"solargraph.formatting": true,
"solargraph.completion": true,
"solargraph.folding": true,
"solargraph.hover": true,
```

Je laisse a solargraph le travail d’appeller Rubocop avec `formatting` et `diagnostics`. Ou de savoir comment “replier” le code avec `folding`. L’autocompletion s’active avec `completion`. Et `hover` permet d’afficher les informations des méthodes en cas de hover.

### Bundle audit et Bundle outdated

Des fois on veut pouvoir vérifier directement en console l’état de nos dépendences. Pour ce faire, on va utiliser deux outils.

##### bundle outdated

Cette commande vient de base avec bundler et lui permet de lister toutes les gems de notre `Gemfile.lock` qui ne sont pas à jour. De plus ça nous indique pour chaque `gem` quelle est la version à jour vers laquelle update. Il ne reste alors plus qu’a faire `bundle update`

##### bundle audit

[Bundle audit](https://github.com/rubysec/bundler-audit) est une extension de bundler qui permet de vérifier si une de nos gems à une faille de sécurité connue (CVE). On utilise la gem de cette manière:

On l’ajoute au `.gemspec`:

```ruby
spec.add_development_dependency "bundle-audit"
```

Puis:

```bash
# Met à jour ta liste des CVEs
bundle audit update
# Vérifie si une de mes gems à une CVE connue
bundle audit
```

### Overcommit

On a déjà plein d’outils de qualité de code qu’on aimerait lancer automatiquement pour éviter de les oublier. Pour cela on va utiliser la gem [overcommit](https://github.com/sds/overcommit). Elle permet de facilement définir une liste de taches à lancer avant chaque `commit` ou `push` git.

Comme d’habitude on ajoute la gem à notre `.gemspec`

```ruby
spec.add_development_dependency "overcommit"
```

On va ensuite “installer” les git hooks:

```bash
bundle exec overcommit -i
```

Enfin, on va configurer overcommit pour lui indiquer quelles actions lancer:

<FileName filename=“.overcommit.yml” />


```yaml
# Avant chaque commit
PreCommit:
  # Lance rubocop sur les fichiers ruby qui ont changé.
  # Si il y a un problème, empêche le commit.
  RuboCop:
    enabled: true
    # Utilise le mode rapide de rubocop
    command: ["rubocop", "-P"]
    quiet: false
  # Vérifie si il y a des gems outdated et affiche un warning sinon
  BundleOutdated:
    enabled: true
  # Vérifie si il y a des CVEs et bloque le commit si oui.
  BundleAudit:
    enabled: true

# Avant chaque push
PrePush:
  # Lance rspec et empêche le push si il y a un problème.
  RSpec:
    enabled: true
    command: ["rspec", "-f", "p"]
    quiet: false
```

Et c’est tout.

On ne lance pas RSpec à chaque commit car ceux-ci peuvent être très longs et on va vouloir encourager de petits commits. Si chaque commit prend 20 minutes, on ne va jamais commit.

Note: A chaque fois que le fichier `.overcommit.yml` change pour des raisons de sécurité on va devoir faire `bundle exec overcommit --sign`

##### Bonus: lancer rubocop (rapide) sur l’ensemble du projet avant le push

À l’heure où cet article est écrit, il n’existe pas de façon pré-écrite de lancer Rubocop sur tous les fichiers avant chaque `push`. Voilà une recette pour remédier au problème:

On ajoute le fichier:

<FileName filename=“.git-hooks/pre_push/rubocop.rb” />


```ruby
# frozen_string_literal: true

module Overcommit
  module Hook
    module PrePush
      # Runs `rubocop` on every files.
      class Rubocop < Base
        def run
          result = execute(['rubocop', '-P'])
          return :pass if result.success?

          output = result.stdout + result.stderr
          [:fail, output]
        end
      end
    end
  end
end
```

Et ensuite on modifie notre `.overcommit.yml`

```yaml
# Avant chaque push
PrePush:
  # […]
  Rubocop:
    enabled: true
```

Et voilà !

### Yard

### Zeitwerk

## Des bonnes pratiques

### Écrire un changelog

### Écrire des tests

Coverage min avec simplecov

### Écrire de la documentation

Readme
Yard

### Automatiser son déploiement

Deploiement se fait sur rubygems

`rake release`

J'utilise des Github Actions pour ça

##### Verifier la version et lancer les tests a chaque push

##### Lancer les tests et déployer au besoin sur les push dans la branche `main`

<FooterArticle prId={10} />
