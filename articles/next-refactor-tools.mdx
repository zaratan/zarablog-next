---
title: "JavascriptÂ : Outils de dev"
date: 2021-02-22T16:02:13+09:00
categories:
  - front
  - tools
  - code
description: "Un tour des diffÃ©rents outils que jâ€™utilise pour gÃ©rer mon dÃ©veloppement en Javascript"
---

Dans un [prÃ©cÃ©dent article](./create-a-new-gem) je vous ai exposÃ© lâ€™ensemble des outils que jâ€™utilise pour automatiser le dÃ©ploiement dâ€™une gem. Aujourdâ€™hui, je vais vous prÃ©senter ma stack pour un projet NextJS ou tout autre projet Ã  base de JS.

## Attentes lors du dÃ©veloppement

En tant que dÃ©veloppeur les points les plus importants sontÂ :

- La vitesse Ã  laquelle jâ€™ai du feedback : Si je dois attendre 2 secs Ã  chaque fois que je sauve un fichier pour savoir si ce que jâ€™ai fait est correct Ã§a va me sortir de mon flow de pensÃ©es le temps que jâ€™ai le retour. La productivitÃ© sera vraiment rÃ©duite.
- DÃ©tecter les erreurs au plus tÃ´t : Il faut que les outils soient disponibles de faÃ§on quasi automatique pendant le dÃ©veloppement et pas quand je dÃ©ciderai de commit et que je me rends compte des centaines dâ€™erreurs.
- Ne pas se mettre en travers de mon chemin : Si un outil bloque mon flow de pensÃ©e pour me forcer Ã  fixer des erreurs de syntaxe, cet outil va juste me ralentir.
- GÃ©rer pour moi une partie de la complexitÃ© : Si lâ€™outil me permet dâ€™oublier une partie des choses et celui-ci me rappellera que je suis un â€œ_idiot_â€ en me proposant la solution câ€™est parfait.

On va voir quâ€™on a rarement tout en mÃªme temps et quâ€™en gÃ©nÃ©ral on doit composer avec certains dÃ©fauts, car ils sont Ã©crasÃ©s par les bÃ©nÃ©fices de lâ€™outil.

### TypeScript

Pour ceux qui ne le savent pas, quâ€™est-ce que TypeScriptÂ : Câ€™est un langage dÃ©veloppÃ© par Microsoft qui sera transformÃ© en JS. Il ajoute la notion de â€œtypeâ€ aux dÃ©clarations de constantes et de fonctions et vÃ©rifie que ce type est respectÃ©/consistant au travers de notre application. De nombreux IDEs ont une trÃ¨s bonne intÃ©gration avec TypeScript en sâ€™en servant pour faire de lâ€™autocompletion et afficher de la documentation.

VoilÃ  un exemple succinct de TS (un article ne parlant que de Ã§a verra surement le jour dans les prochaines semaines/mois).

```ts
type Item = {
  key: string;
  properties: Array<{ name: string; value: string | number }>;
};

const item: Item = {
  key: "table",
  properties: [{ name: "legs", value: 4 }],
};

const countLegs = (items: Array<Item>) =>
  items.reduce<number>(
    (res, item) =>
      res + (item.properties.find((e) => e.name === "legs")?.value || 0)
  );
```

Venant de Ruby, mettre Ã  nouveau un type Ã  mes objets fut trÃ¨s Ã©trange. AprÃ¨s mâ€™Ãªtre fait brÃ»ler â€œ_quelques_â€ fois par les â€œparticularitÃ©sâ€ de JS ou des librairies associÃ©es, je trouve que TypeScript me sauve plus de temps quâ€™il ne mâ€™en coute.

Cet outil nâ€™est clairement pas sans dÃ©fauts ğŸ˜¶ Et on va en lister ici quelques-uns.

- Les erreursÂ : Lire une erreur TS est Ã  peu prÃ¨s aussi utile que lire un roman dans une langue Ã©trangÃ¨re inconnue et quâ€™on ne veut pas apprendre. Elles sont obscures et nâ€™aident pas du tout Ã  leur rÃ©solution. Bien heureusement, on apprend petit Ã  petit Ã  ne plus tomber dans les piÃ¨ges qui les font sortir du bois. Ici, TS se met en travers du chemin.
- Typer les choses prends du tempsÂ : ajouter des dÃ©clarations de type partout, prendre le temps de [comprendre](https://www.typescriptlang.org/docs/handbook/utility-types.html) [comment](https://www.typescriptlang.org/docs/handbook/declaration-merging.html) [marche](https://www.typescriptlang.org/docs/handbook/advanced-types.html) le typage et rÃ©flÃ©chir en amont Ã  la forme des objets qui seront utilisÃ©s, va clairement ralentir la cadence.
- Typer les choses est moins flexible et parfois difficile (notamment quand on veut crÃ©er des fonctions un peu gÃ©nÃ©riques qui acceptent plusieurs types)

La force de cet outil se trouve dans ce genre de casÂ :

```ts
// <input type="text" onchange="onChange">
const onChange = (event) => {
  event.current.target;
  event.target;
};
```

Seriez-vous capable de me donner la liste des fonctions prÃ©sentes sur `event.target` et `event.current.target` et Ãªtre sÃ»r que vous les utilisez avec le bon type dâ€™arguments ? Moiâ€¦ non. TS, oui.

Ou encore, cas que j'ai eu tout rÃ©cemment, un besoin d'utiliser les APIs de chrome pour les extensions.

<Image
  src="/articles/next-refactor-tools/typescript_chrome_autocomplete.png"
  height="552"
  width="1702"
  alt="Chrome extension API autocomplete"
/>

Typescript, mÃªme sâ€™il est parfois dans mon chemin, me libÃ¨re Ã©normÃ©ment dâ€™espace mental quant au format des choses que je vais recevoir et comment les utiliser. De plus il me trouve des erreurs avant mÃªme quâ€™elles nâ€™arriventâ€¦ Dans le navigateur des clients.

##### Activer TS dans un projet NextJS

Pour ceux qui cherchent la faÃ§on de lâ€™activer et lâ€™utiliser dans NextJS il suffit de faire, Ã  la racine de votre projetÂ : `touch tsconfig.json` et de relancer votre serveur de dev. Votre projet acceptera maintenant les fichiers `.ts` et `.tsx`.

Pour un peu plus dâ€™informations, je vous renvoie vers [la page de documentation correspondante](https://nextjs.org/docs/basic-features/typescript)

Maintenant quâ€™on a un outil qui dÃ©tecte une partie des erreurs et gÃ¨re la documentation du code. On va rÃ©gler les problÃ©matiques de style.

### Prettier

[Prettier](https://prettier.io), est un outil qui permet de formater le code de maniÃ¨re automatique. Les principales diffÃ©rences avec [Rubocop](http://rubocop.org/) ou [Eslint](#eslint) sont les suivantesÂ :

- Prettier utilise un [AST](https://prettier.io/docs/en/index.html) pour reformater le code. PlutÃ´t quâ€™un outil qui ne comprend pas vraiment la logique dâ€™une ligne de code, prettier va dÃ©composer vos lignes de code sous la forme dâ€™un arbre et sâ€™en servir pour rendre un code qui suit ses diffÃ©rentes rÃ¨gles. Prettier a donc beaucoup plus de facilitÃ©s Ã  traiter des lignes complexes ou forcer des sauts de ligne aux bons endroits.
- Prettier nâ€™a presque pas dâ€™options de configuration. Lâ€™idÃ©e est de couper les â€œ_nombreuses_â€ discussions inutiles qui apparaissent lorsquâ€™on dÃ©cide de la faÃ§on dont on va formater notre code. Comme beaucoup de projets se sont mis Ã  utiliser Prettier, Ã  travers lâ€™Ã©cosystÃ¨me javascript, beaucoup de projets ont une allure trÃ¨s similaire maintenant.
- Prettier nâ€™a pas de rÃ¨gles quant Ã  la qualitÃ© de code. Prettier nâ€™a aucun problÃ¨me Ã  ce que votre code ait des variables inutilisÃ©es ou des problÃ¨mes de performance/sÃ©curitÃ©.

##### Comment ajouter Prettier Ã  un projet ?

On commence par ajouter prettier Ã  nos outils de dÃ©veloppement.

```bash
 yarn add -D prettier
```

On est maintenant capable de lancer la commande

```bash
yarn prettier --writte mon/path/vers/mon/fichier.ts
```

VoilÃ . Je ne vais pas parler de lâ€™intÃ©gration entre prettier et un Ã©diteur, car on va voir quâ€™on utilisera quasiment jamais prettier seul. On va utiliser un autre outil pour le lancer. Cet outil sera aussi responsable de gÃ©rer les rÃ¨gles de qualitÃ© de code.

### ESlintÂ : One tool to run them all

ESlint est Ã  Javascript ce que Rubocop est Ã  ruby. Câ€™est un linter, trÃ¨s configurable qui prend en charge un grand Ã©ventail de rÃ¨gles et de plugins.

La configuration minimale d'ESlint ressemble Ã Â :

<FileName filename=".eslintrc.js" />

```js
module.exports = {
  root: true,
  extends: [],
  env: {
    browser: true,
  },
  rules: {},
  plugins: [],
  ignorePatterns: [],
};
```

On va construire "ensemble" cette configuration.

##### Style dâ€™Airbnb + React

Tout d'abord j'aime partir d'un style guide prÃ©-fait et qui est sensible. J'aime bien utiliser le [style-guide d'Airbnb](https://airbnb.io/javascript/) avec qui je suis assez souvent d'accord. IntÃ©grer chaque rÃ¨gle Ã  la main dans ESlint serait bien complexe. On peut donc partir de leur extensionÂ : Pour [React](https://www.npmjs.com/package/eslint-config-airbnb) et pour [Non-React](https://www.npmjs.com/package/eslint-config-airbnb-base).

On va passer au travers de la configuration pour un projet React (et donc next).

Tout d'abord, l'ajouter a notre projet:

```bash
npx install-peerdeps --dev eslint-config-airbnb
```

Ce "script" va dÃ©tecter si on utilise `npm` ou `yarn` et installer avec les diffÃ©rentes dÃ©pendances (dont `eslint`).

Ã€ l'heure de l'Ã©criture de cet article, cette commande va ajouter Ã  notre package.jsonÂ :

<FileName filename="package.json" />

```js
"eslint": "^7.2.0",
"eslint-config-airbnb": "18.2.1",
"eslint-plugin-import": "^2.22.1",
"eslint-plugin-jsx-a11y": "^6.4.1",
"eslint-plugin-react": "^7.21.5",
"eslint-plugin-react-hooks": "^1.7.0"
```

On peut ensuite l'ajouter Ã  notre configuration

```js
module.exports = {
  root: true,
  extends: ["airbnb"],
  env: {
    browser: true,
  },
  rules: {},
  plugins: ["react-hooks"],
  ignorePatterns: [],
};
```

##### IntÃ©gration avec Prettier

Avoir deux outils diffÃ©rents qui rÃ©gissent notre syntaxe et sont parfois en contraction est "_peu_" optimal. Il y a plusieurs mÃ©thodes pour faire Ã§a, mais on va se concentrer sur celle qui marche le mieuxÂ :

On va faire en sorte que ESlint soit responsable de lancer Prettier et respecte les dÃ©cisions de ce dernier.

On commence par installer les plugins Prettier pour ESlintÂ :

```bash
yarn add -D eslint-config-prettier eslint-plugin-prettier
```

On modifie ensuite notre configuration pour les utiliserÂ :

```js
module.exports = {
  root: true,
  extends: ["airbnb", "prettier", "plugin:prettier/recommended"],
  env: {
    browser: true,
  },
  rules: {
    // On configure prettier
    "prettier/prettier": [
      "error",
      {
        trailingComma: "es5",
        singleQuote: true,
        printWidth: 80,
        semi: true,
      },
    ],
  },
  plugins: ["prettier", "react-hooks"],
  ignorePatterns: [],
};
```

VoilÃ .

##### IntÃ©gration avec Typescript

En fait, on avait un troisiÃ¨me outil responsable de vÃ©rifier notre codeÂ : TypeScript. Pour l'instant ESlint est configurÃ© pour fonctionner avec des fichiers Javascript normaux. On va donc faire en sorte qu'il soit compatible avec TypeScriptÂ :

```bash
yarn add -D @typescript-eslint/eslint-plugin @typescript-eslint/parser
```

On l'ajoute Ã  notre configurationÂ :

```js
module.exports = {
  root: true,
  parser: "@typescript-eslint/parser",
  extends: [
    "airbnb",
    "prettier",
    "plugin:prettier/recommended",
    "plugin:@typescript-eslint/eslint-recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:import/typescript",
  ],
  env: {
    browser: true,
  },
  rules: {
    // On configure prettier
    "prettier/prettier": [
      "error",
      {
        trailingComma: "es5",
        singleQuote: true,
        printWidth: 80,
        semi: true,
      },
    ],
  },
  plugins: ["prettier", "react-hooks", "@typescript-eslint"],
  ignorePatterns: ["next-env.d.ts"],
};
```

On a donc maintenant ESlint responsable de lancer et vÃ©rifier notre code avec nos trois outils.

##### Configuration finale et commentaires

VoilÃ  ma configuration pour eslint que jâ€™utilise pour tous mes projets React/NextÂ :

J'ai pas mal de rÃ¨gles custom qui viennent de nombreuses itÃ©rations. Certaines ne sont peut-Ãªtre plus "si" utiles, mais je vous la laisse telle quelle :

<FileName blogGithub filename=".eslintrc.js" />

```js
module.exports = {
  root: true,
  parser: "@typescript-eslint/parser",
  extends: [
    "airbnb",
    "prettier",
    "plugin:prettier/recommended",
    "plugin:@typescript-eslint/eslint-recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:import/typescript",
  ],
  env: {
    browser: true,
    node: true,
    jquery: true,
    jest: true,
  },
  rules: {
    // const > let >>>> var
    // On va aussi destructurer les object autant que possible
    "prefer-const": [
      "error",
      {
        destructuring: "all",
      },
    ],
    // Les arrow functions auront des {} seulement si nÃ©cessaire.
    "arrow-body-style": [2, "as-needed"],
    // Detecte les cas ou des lignes sont inutilisÃ©es
    // Le allowTaggedTemplates est lÃ  pour de la compatibilitÃ© avec
    // styled-components
    "no-unused-expressions": [
      2,
      {
        allowTaggedTemplates: true,
      },
    ],
    "no-param-reassign": [
      2,
      {
        props: false,
      },
    ],
    // On autorise les console.log car je l'utilise trop souvent en debug
    // pour accepter que JS me crie dessus.
    "no-console": 0,
    // Il y a des cas oÃ¹ on veut juste un named export dans un fichier
    // nottament en cours de dev. Je ne suis pas sÃ»r qu'il y ait un rÃ©el
    // intÃ©rÃªt Ã  cette rÃ¨gle qui vient de AirBnb.
    "import/prefer-default-export": 0,
    import: 0,
    // Il y a des cas oÃ¹ on va vouloir des fonctions anonymes en JS
    "func-names": 0,
    // J'aime bien ne pas avoir d'espace avant les () dans une dÃ©claration
    "space-before-function-paren": 0,
    // C'est le taf de prettier
    "comma-dangle": 0,
    "max-len": 0,
    "import/extensions": 0,
    "no-underscore-dangle": 0,
    // Il y a des cas tout Ã  fait valide de renvoyer soit null soit
    // un objet dans une fonction. C'est le travail de TS de trouver
    // ces erreurs.
    "consistent-return": 0,
    // Chaque composant doit avoir un nom. C'est affreux a debug sinon.
    "react/display-name": 1,
    "react/no-array-index-key": 0,
    "react/react-in-jsx-scope": 0,
    "react/prefer-stateless-function": 0,
    "react/forbid-prop-types": 0,
    "react/no-unescaped-entities": 0,
    // Emoji everywhere
    "jsx-a11y/accessible-emoji": 0,
    "react/require-default-props": 0,
    // On liste les extensions de fichiers qui peuvent contenir du JSX
    "react/jsx-filename-extension": [
      1,
      {
        extensions: [".js", ".jsx", ".ts", ".tsx"],
      },
    ],
    radix: 0,
    // Ã‡a sera gÃ©rÃ© par Prettier
    quotes: [
      2,
      "single",
      {
        avoidEscape: true,
        allowTemplateLiterals: true,
      },
    ],
    // On configure prettier
    "prettier/prettier": [
      "error",
      {
        trailingComma: "es5",
        singleQuote: true,
        printWidth: 80,
        semi: true,
      },
    ],
    // Des fois c'est pratique d'avoir des liens avec
    // '#' ou des valeurs invalides comme href
    // lors du prototypage.
    "jsx-a11y/href-no-hash": "off",
    "jsx-a11y/anchor-is-valid": [
      "warn",
      {
        aspects: ["invalidHref"],
      },
    ],
    // Marquer le non-repect des rÃ¨gles de hook comme des erreurs.
    "react-hooks/rules-of-hooks": "error",
    // Marquer le fait qu'il manque des dÃ©pendances dans les useEffect
    // comme un warning.
    "react-hooks/exhaustive-deps": "warn",
    // Les 2 rÃ¨gles suivantes sont lÃ  pour autoriser
    // Ã  ce que les fonctions et modules ne soient pas typÃ©s.
    // En effet, dans un contexte React, la plupart du temps nos
    // fonctions seront des composants et leur typage sera inutile.
    "@typescript-eslint/explicit-function-return-type": 0,
    "@typescript-eslint/explicit-module-boundary-types": 0,

    // Les rÃ¨gles suivantes sont prÃ©sente pour un dÃ©faut de
    // compatibilitÃ© entre ESlint et Typescript.
    // On desactive les rÃ¨gles de ESLint et
    // on active les rÃ¨gles de typescript-eslint correspondantes.

    // La plupart du temps on veut que eslint hurle quand des variables
    // ne sont pas utilisÃ©es. On autorise certains patterns classiques.
    // notamment les variables commenÃ§ant par _
    "no-unused-vars": "off",
    "@typescript-eslint/no-unused-vars": [
      1,
      {
        argsIgnorePattern: "res|next|Sequelize|^err|^_.*",
      },
    ],
    "no-use-before-define": "off",
    "@typescript-eslint/no-use-before-define": ["error"],
    "no-shadow": "off",
    "@typescript-eslint/no-shadow": ["error"],
  },
  // Les diffÃ©rents plugins
  plugins: ["prettier", "react-hooks", "@typescript-eslint"],
  // Ces fichiers ne sont pas Ã©crits par nous.
  ignorePatterns: ["next-env.d.ts", "node_modules/", "/public/"],
};
```

Cette configuration s'intÃ¨gre trÃ¨s bien avec VSCode et son extension [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint).

### Husky + lint-staged

On va maintenant faire en sorte que ces rÃ¨gles et outils soient "forcÃ©s" lors d'un commit ou un push.

Pour Ã§a on utilise deux outils sÃ©parÃ©sÂ :

- [Husky](Note%20pour%20plus%20tard%20:%20Je%20sais%20jamais%20comment%20interpr%C3%A9ter%20ce%20genre%20de%20messages), qui va gÃ©rer pour nous les git hooks.
- [Lint-staged](https://github.com/okonet/lint-staged), qui ne va lancer des commandes que sur certains fichiers.

L'installation et configuration est assez simpleÂ :

On installe les librairiesÂ :

```bash
yarn add -D husky lint-staged
```

On ajoute quelques scripts dans `package.json`

```json
{
  â€¦
  "scripts": {
    â€¦
    // Ajoute une commande `yarn lint` pour lancer eslint
    "lint": "eslint .",
    // Assure que les hooks de husky sont intallÃ©s automatiquement
    "postinstall": "husky install"
  }
  â€¦
}
```

On ajoute ensuite la configuration pour lint-staged au `package.json`

```json
{
  â€¦
  "lint-staged": {
    // Tous les fichiers js(x) et ts(x) qui vont Ãªtre commit seront check.
    "*.js": "eslint --cache --fix",
    "*.jsx": "eslint --cache --fix",
    "*.ts": "eslint --cache --fix",
    "*.tsx": "eslint --cache --fix"
  }
}
```

Ensuite on configure les diffÃ©rents husky hooksÂ :

Au commit on lance lint-staged

<FileName filename=".husky/pre-commit" blogGithub />

```bash
/sh
. "$(dirname "$0")/_/husky.sh"

yarn lint-staged
```

Au push on vÃ©rifie tous nos fichiers.

<FileName filename=".husky/pre-push" blogGithub />

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

yarn lint
```

## Conclusion

VoilÃ  un article assez simple qui donne la configuration des quelques outils que j'utilise pour mes projets Javascript. Vous devriez pouvoir l'utiliser quasiment telle quelle.

De plus, j'espÃ¨re que Ã§a vous aura donnÃ© une idÃ©e de ce que j'utilise pour choisir d'intÃ©grer (ou non) un nouvel outil dans ma stack.

<FooterArticle
  prId={11}
  helpers={[{ name: "@Showner", link: "https://twitter.com/showner_dev" }]}
/>
